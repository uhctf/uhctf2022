# Solution
The given binary contains a buffer overflow vulnerability. The function `int get_quote()` uses `gets` to read data from stdin. `gets` is very unsafe as it reads data until it encounters a `\n`, or EOF. However, the buffer that stores the input is only 128 bytes big. Thus, any input longer than 128 bytes, including the newline, will *overflow* the buffer. This buffer is stored on the stack. The overflow will thus overwrite bytes that follow the buffer, as if that data would also be part of the buffer.

With a buffer overflow vulnerability it is possible to overwrite the return address on the stack. The return address is the memory address to which execution should return after returning from the current function. In normal circumstances this is the calling function. However, if we overwrite these byte, the program flow will be redirected.

Redirecting to non-executable code will result in the infamous segmentation fault error. If we throw the given binary into Ghidra, or equivalent, we will see that the function `flagged` is not used. Redirecting execution to it is as simple as getting the function's address, adding the base address at which the binary is loaded, and spamming the resulting value onto the stack after the bytes that overflow the stack. The base address is `0x56555000` and can be discovered by running the binary and listing `/proc/<process_id>/maps`. (Remember to disable ASLR on the host!) The function's offset is `0x000006e0` and can be found with Ghidra. (Remember that Ghidra sets its own base address, which is by default `0x00010000` for x86!)